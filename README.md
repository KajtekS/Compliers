Compliers
<h3>Problem</h3>

I wrote this program to create a 'special' calculator that recognizes the order of mathematical operations, such as addition, subtraction, multiplication, and division. This problem can be solved more easily with traditional methods, but the goal of this program was to apply the principles of compiler theory and parsing in real-world applications. By using such a method, we not only gain deeper insights into how compilers work but also open up possibilities for solving more complex problems. This approach has a significant advantage: it scales well and can be extended to handle more sophisticated tasks beyond simple arithmetic.

<h3>Parts of the Program</h3>

1. <h4>Lexer</h4> The lexer is responsible for translating the input into a sequence of tokens. Each token 
   represents a basic 
element of the input, such as numbers or operators. Tokens are special C++ structures containing two primary fields: the token type (such as NUMBER, PLUS, MINUS, etc.) and the token value (which represents the value of a number or is set to 0 for operators since operators do not have numeric values). The lexer essentially breaks down the input string into manageable chunks, providing the parser with a stream of tokens to process.
2. <h4>Parser</h4> The parser takes the stream of tokens and organizes them into a parse tree. This tree is a 
   hierarchical 
   structure that represents the syntactic structure of the mathematical expression. The parser ensures that the operations are performed in the correct order, following mathematical precedence rules. For instance, multiplication and division are evaluated before addition and subtraction. By organizing the tokens into a tree, the parser prepares the expression for evaluation in a way that respects the rules of arithmetic.
3. <h4>Code Generator (Codegen)</h4> After the parse tree is created, the code generator takes this tree and 
   translates it 
   into a sequence of low-level operations. These operations are typically stack-based, involving simple instructions like PUSH (to push a value onto the stack) and POP (to retrieve a value from the stack). Code generation is essential because it converts the abstract representation of an expression into executable steps that can be processed by a virtual machine or an actual processor.
4. <h4>Virtual Machine (VM)</h4> The virtual machine executes the code generated by the previous step. It interprets 
   the 
   stack 
   operations (such as pushing and popping values onto/from the stack) and performs the corresponding arithmetic operations, effectively evaluating the mathematical expression. The virtual machine operates on the low-level instructions produced by the code generator, simulating how the CPU would process the code in a real-world scenario. It ensures that the operations are carried out in the correct order and produces the final result.
